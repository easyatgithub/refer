<pre>
  <br />
  SPA（ single-page application ）单页运用
  <br />
  优点：
  用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
  基于上面一点，SPA 相对对服务器压力小；
  前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
  <br />缺点： <br />
  初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将
  JavaScript、CSS 统一加载，部分页面按需加载；
  前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
  SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO
  上其有着天然的弱势。
   
  v-if是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
  v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS
  的 “display” 属性进行切换。 所以，v-if
  适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show
  则适用于需要非常频繁切换条件的场景。

  所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop
  的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
  额外的，每次父级组件发生更新时，子组件中所有的 prop
  都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变
  prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过
  $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

  当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用
  computed 的缓存特性，避免每次获取值时，都要重新计算；
  当我们需要在数据变化时执行异步或开销较大的操作时，应该使用
  watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API
  )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。
  beforeCreate 组件实例被创建之初，组件的属性生效之前
  created 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用
  beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted el
  被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate
  组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update 组件数据更新之后
  activited keep-alive 专属，组件被激活时调用 deactivated keep-alive
  专属，组件被销毁时调用 beforeDestory 组件销毁前调用 destoryed 组件销毁后调用
  
   
  而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。data 是数组
  因为组件是用来复用的，且 JS 里对象是引用关系 如果组件中 data
  是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，
  如果组件中 data
  选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的
  data 属性值不会互相影响；
   
  主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定
  父子组件通信
   
  （1）props / $emit （2）ref 与 $parent / $children
  
  EventBus （$emit / $on） 所有 通过一个空的 Vue 实例作为中央事件总线（事件中心
 
  
  用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； 

  diff 算法 —比较两棵虚拟 DOM 树的差异；
  pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的DOM 树。

  （1）代码层面的优化

  v-if 和 v-show 区分使用场景
  computed 和 watch  区分使用场景
  v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
  长列表性能优化
  事件的销毁
  图片资源懒加载
  路由懒加载
  第三方插件的按需引入
  优化无限列表性能
  服务端渲染 SSR or 预渲染
  
  （2）Webpack 层面的优化
  
  Webpack 对图片进行压缩
  减少 ES6 转为 ES5 的冗余代码
  提取公共代码
  模板预编译
  提取组件的 CSS
  优化 SourceMap
  构建结果输出分析
  Vue 项目的编译优化
  
  （3）基础的 Web 技术的优化
  
  
  开启 gzip 压缩
  
  
  浏览器缓存
  
  
  CDN 的使用
  
  
  使用 Chrome Performance 查找性能瓶颈
  
  作者：我是你的超级英雄
  链接：https://juejin.im/post/5d59f2a451882549be53b170
  来源：掘金
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



before ed
 
4个阶段
创建-载入-更新-销毁
4个阶段 分别有before 与完成状态
4个阶段都是先进入子组件完成内容再完成父组件内容
比如销毁 

defineProperty get set 函数双向绑定
路由实现：hash模式 和 history模式
















</pre>
